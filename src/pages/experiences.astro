---
import InlineCode from "../components/elements/InlineCode.astro";
import Line from "../components/elements/Line.astro";
import Experience from "../components/layout/Experience.astro";
import MultiExperiences from "../components/layout/MultiExperiences.astro";
import MultiExperiencesItem from "../components/layout/MultiExperiencesItem.astro";
import Conecsio from "../images/companies/Conecsio.svg";
import ScalaCenter from "../images/companies/scala-center.webp";
import Teads from "../images/companies/Teads.svg";
import Layout from "../layouts/Layout.astro";

const teadsLink = "https://www.teads.com";
---

<Layout title="Experiences">
  <section slot="hero" id="page-header">
    <h1 class="anim-fade-translate">Experiences</h1>
  </section>

  <section>
    <h1>2025</h1>
    <MultiExperiences
      company="Teads"
      location="MPL"
      img={Teads}
      link={teadsLink}
    >
      <MultiExperiencesItem
        title="Software Engineer @ SSP Video"
        startDate="Mar. 2025"
      >
        <span slot="stack">
          Stack: Scala, AWS, Terraform, Grafana (Loki, Tempo)
        </span>

        <dl>
          <dt>Infrastructure</dt>
          <dd>
            <ul>
              <li>Moved application to ARM to reduce costs</li>
              <li>Handled ~20 billions requests / day</li>
              <li>AWS us-east-1 outage management</li>
            </ul>
          </dd>
          <dt>Alerting & Monitoring</dt>
          <dd>
            <ul>
              <li>Implemented tracing with Grafana & Tempo</li>
              <li>
                Reworked alarms to make them more relevant and reduce spam
              </li>
              <li>Metric-based deployment</li>
            </ul>
          </dd>
          <dt>Business</dt>
          <dd>
            <ul>
              <li>Worked on the link between exTeads and exOutbrain</li>
            </ul>
          </dd>
        </dl>
      </MultiExperiencesItem>

      <MultiExperiencesItem
        title="Software Engineer @ Format"
        startDate="Mar. 2024"
        endDate="Feb. 2025"
      >
        <span slot="stack">
          Stack: Scala, Typescript, GitHub Actions, Terraform, Jenkins, AWS,
          Grafana & Loki, Kibana
        </span>

        <dl>
          <dt>Jenkins to Github Actions</dt>
          <dd>
            Migrated both the CI & Deployment pipeline from Jenkins to GitHub
            Actions & adapted it to better match our needs (more
            parallelization, caching, readbility etc.)
          </dd>
          <dt>Newer encodings for ads</dt>
          <dd>
            <ol>
              <li>
                Migrated the service used to encode ads from a legacy API to a
                newer one so we could move forward and introduce more performant
                encodings. Used the double-run strategy to ensure correctness
              </li>
              <li>
                Streamlined the worklow: SQL batch writes, parallelized SQL read
                queries etc.
              </li>
              <li>
                Introduced segmented video encodings with AWS MediaConvert,
                reducing resource consumption on both client & server side. Used
                event-based architecture with events, queues, etc. Gracefully
                handle failed event processing by retrying only what is
                necessary. Encoding process are templetized and versionned to be
                easier to use and future-proof
              </li>
              <li>Set up monitoring & alerting through CloudWatch & Grafana</li>
            </ol>
          </dd>
          <dt>Technical debt removal</dt>
          <dd>
            Cleaned up (deduplication, use native construct instead of custom
            ones, etc.) legacy parts of the format's codebase to reduce
            accidental complexity and improve development speed, as well as
            confidence in the codebase. Since it's a critical part of the
            delivery each change affecting the codebase is going through a
            technical A/B test to ensure there's no regression.
          </dd>
        </dl>
      </MultiExperiencesItem>
    </MultiExperiences>

    <Line />

    <Experience
      title="End of studies project"
      company="Conecs.io"
      location="Montpellier, France"
      startDate="Dec. 2023"
      endDate="Feb. 2024"
      img={Conecsio}
      link="https://www.conecsio.com"
    >
      <i><small>Stack: Rust, Advanced Encryption Methods</small></i>
      <ul>
        <li>
          POC on a privacy-preserving storage for clinical data with special
          encryption methods to allow re-using & sharing data easily across
          multiple actors, <b>only if</b> the patient allows it.
        </li>
        <li>
          Reviewed several research papers to understand how these methods work,
          their use cases, limitations, risks, etc.
        </li>
        <li>
          Implemented a small POC with Rust ðŸ¦€ as it's extremely CPU-efficient
          and a POC isn't used in production, so it was a nice opportunity to
          learn a new language :)
        </li>
      </ul>
    </Experience>

    <Line width="80%" />

    <h1>2023</h1>
    <Experience
      title="Software Engineer Intern"
      company="Scala Center"
      location="Lausane, Switzerland"
      startDate="Apri. 2023"
      endDate="Aug. 2023"
      img={ScalaCenter}
      link="https://scala.epfl.ch"
      id="scala-center-internship"
    >
      <i><small>Tech: Scala, JVM, Scala-Java interop, Reflection</small></i>
      <p>
        Improved the Scala debugger in VS Code with a new evaluation mode, using
        runtime reflection. It is limited to expressions that can be <u
          >correctly</u
        > evaluated at runtime (e.g., in the case of an overridden method, using
        reflection we could pick a method different from what the compiler would
        have chosen).
      </p>
      <p>The evaluation is performed in 2 phases:</p>
      <ol>
        <li>
          Validate the expression: correct syntax, evaluable using reflection.
          Transform the expression AST into a custom ADT representing the
          expression, that can later be evaluated.
        </li>
        <li>Evaluate the expression.</li>
      </ol>
      <p>
        This evaluation includes a <InlineCode>pre-evaluation</InlineCode> mode.
        Instead of using the compile-time type of a value, <u>if possible</u> we
        evaluate it and use its runtime type. It eases the access to runtime information
        during debugging.
      </p>
      <p>
        I particularly enjoyed the compiler-related part of the project: ASTs,
        type checking, overload resolution, etc.
      </p>
      <p>
        As a secondary project, I helped with the implementation of Hot Code
        Replacement (HCR). This means that we can now launch a debug session,
        change the code, and just reload the session (so we keep the "progress"
        made +/-) instead of restarting from the beginning.
      </p>
    </Experience>

    <Line width="80%" />

    <h1>2022</h1>
    <Experience
      title="Assistant Software Engineer"
      company="Teads"
      location="Montpellier, France"
      startDate="Jun. 2022"
      endDate="Aug. 2022"
      img={Teads}
      link={teadsLink}
    >
      <i>
        <small
          >Stack: Scala, Typescript, gRPC, React, Git, GitHub, Cypress, Jenkins
        </small>
      </i>
      <p>
        2-month internship where I worked on the V2 of their demo application. I
        did some backend development with Scala & the Typelevel ecosystem
        (Cats-effect, doobie...) followed by a more front-end part (in the end I
        worked on both backend & frontend at the same time).
      </p>

      <p>
        For each feature I developed, I was responsible for the whole lifecycle:
        code, test, deploy, refactor, fix bugs...
      </p>
    </Experience>
  </section>
</Layout>

<style>
  li + li {
    margin-top: 0.5em;
  }

  dt {
    font-weight: bold;
    margin-top: 1em;
  }
</style>
